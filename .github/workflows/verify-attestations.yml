name: Verify Artifact Attestations

on:
  workflow_call:
    inputs:
      repository:
        description: >
          Repository whose releases to verify (owner/repo format).
          Defaults to the calling repository when not specified.
        required: false
        type: string
        default: ''
      tag:
        description: >
          Literal release tag to verify (e.g. v1.2.3), OR a semver constraint
          expression to select matching releases (e.g. >=1.2.0, <2.0.0,
          ^1.2.0, ~1.2, >=1.0.0,<2.0.0).
          Checks every release when not specified.
        required: false
        type: string
        default: ''
      limit:
        description: 'Maximum number of releases to check (0 = all, ignored when tag is set)'
        required: false
        type: number
        default: 0
      open-issue:
        description: >
          Open a GitHub issue on the calling repository when verification fails.
          Requires the calling workflow to grant issues: write permission.
        required: false
        type: boolean
        default: false
    outputs:
      verified:
        description: 'Number of artifacts verified successfully'
        value: ${{ jobs.verify.outputs.verified }}
      failed:
        description: 'Number of artifacts that failed verification'
        value: ${{ jobs.verify.outputs.failed }}

jobs:
  verify:
    name: Verify attestations for ${{ inputs.repository || github.repository }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    outputs:
      verified: ${{ steps.verify.outputs.verified }}
      failed: ${{ steps.verify.outputs.failed }}

    steps:
      - name: Verify artifact attestations
        id: verify
        env:
          GH_TOKEN: ${{ github.token }}
          INPUT_REPO: ${{ inputs.repository }}
          TAG: ${{ inputs.tag }}
          LIMIT: ${{ inputs.limit }}
          OPEN_ISSUE: ${{ inputs.open-issue }}
          CALLER_REPO: ${{ github.repository }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          set -uo pipefail

          # ── Semver filter helper (pure Python, no external deps) ────────────
          cat > /tmp/semver_filter.py << 'PYEOF'
          """
          Read release tag names from stdin, print those that satisfy the semver
          constraint given as argv[1].

          Supported operators:  >  >=  <  <=  ==  =  !=
          Caret ranges:  ^1.2.3  →  >=1.2.3,<2.0.0
          Tilde ranges:  ~1.2.3  →  >=1.2.3,<1.3.0
                         ~1.2    →  >=1.2.0,<1.3.0
                         ~1      →  >=1.0.0,<2.0.0
          Comma-separated multi-constraints:  >=1.0.0,<2.0.0
          """
          import re, sys

          def parse_ver(s):
              s = re.sub(r'^[vV]', '', s)
              m = re.match(r'^(\d+)(?:\.(\d+))?(?:\.(\d+))?', s)
              if not m:
                  return None
              return tuple(int(x) if x else 0 for x in m.groups())

          def expand_caret(ver_str):
              v = parse_ver(ver_str)
              if v is None:
                  return None, None
              return v, (v[0] + 1, 0, 0)

          def expand_tilde(ver_str):
              v = parse_ver(ver_str)
              if v is None:
                  return None, None
              segs = re.sub(r'^[vV]', '', ver_str).split('.')
              if len(segs) >= 2:
                  return v, (v[0], v[1] + 1, 0)
              return v, (v[0] + 1, 0, 0)

          def matches(tag, constraint):
              v = parse_ver(tag)
              if v is None:
                  return False
              for part in constraint.split(','):
                  part = part.strip()
                  if not part:
                      continue
                  if part.startswith('^'):
                      lo, hi = expand_caret(part[1:])
                      if lo is None or not (v >= lo and v < hi):
                          return False
                  elif part.startswith('~'):
                      lo, hi = expand_tilde(part[1:])
                      if lo is None or not (v >= lo and v < hi):
                          return False
                  else:
                      m2 = re.match(r'^(>=|<=|==|!=|>|<|=)(.+)$', part)
                      if not m2:
                          ver = parse_ver(part)
                          if ver is None or v != ver:
                              return False
                      else:
                          op, rhs = m2.group(1), parse_ver(m2.group(2))
                          if rhs is None:
                              return False
                          if op in ('==', '=') and v != rhs: return False
                          if op == '!='           and v == rhs: return False
                          if op == '>='           and v <  rhs: return False
                          if op == '<='           and v >  rhs: return False
                          if op == '>'            and v <= rhs: return False
                          if op == '<'            and v >= rhs: return False
              return True

          constraint = sys.argv[1] if len(sys.argv) > 1 else ''
          for tag in sys.stdin.read().splitlines():
              tag = tag.strip()
              if tag and matches(tag, constraint):
                  print(tag)
          PYEOF

          # ── Resolve target repository ───────────────────────────────────────
          REPO="${INPUT_REPO:-}"
          if [ -z "$REPO" ]; then
            REPO="$CALLER_REPO"
          fi

          echo "Repository:            $REPO"
          echo "Tag filter:            ${TAG:-(all releases)}"
          echo "Limit:                 ${LIMIT:-0}"
          echo "Open issue on failure: ${OPEN_ISSUE:-false}"
          echo ""

          # ── Collect the list of tags to verify ─────────────────────────────
          # Detect whether TAG is a semver constraint (starts with an operator
          # or range prefix) or a literal tag name.
          IS_CONSTRAINT=false
          if [ -n "$TAG" ] && printf '%s' "$TAG" | grep -qE '^[><=^~]'; then
            IS_CONSTRAINT=true
          fi

          if [ -n "$TAG" ] && [ "$IS_CONSTRAINT" = "false" ]; then
            # Literal tag — verify exactly this one release
            TAGS="$TAG"
          else
            # Fetch every release via paginated REST API
            echo "Fetching release list for $REPO (paginated) ..."
            ALL_TAGS=$(gh api --paginate "/repos/$REPO/releases" --jq '.[].tag_name')

            if [ "$IS_CONSTRAINT" = "true" ]; then
              echo "Applying semver constraint: $TAG"
              TAGS=$(echo "$ALL_TAGS" | python3 /tmp/semver_filter.py "$TAG")
            else
              TAGS="$ALL_TAGS"
            fi

            # Apply optional limit AFTER fetching / filtering all pages
            if [ "${LIMIT:-0}" -gt 0 ]; then
              TAGS=$(echo "$TAGS" | head -n "$LIMIT")
            fi
          fi

          if [ -z "$TAGS" ]; then
            MSG="No releases found"
            [ "$IS_CONSTRAINT" = "true" ] && MSG="No releases match the constraint '${TAG}'"
            echo "$MSG for $REPO"
            echo "verified=0" >> "$GITHUB_OUTPUT"
            echo "failed=0"   >> "$GITHUB_OUTPUT"
            {
              echo "## Artifact Attestation Verification — \`$REPO\`"
              echo ""
              echo "> [!NOTE]"
              echo "> $MSG."
            } >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          TOTAL_VERIFIED=0
          TOTAL_FAILED=0
          RELEASE_ERRORS=0
          FAILED_LIST_FILE=$(mktemp)

          # ── Step summary header ─────────────────────────────────────────────
          FILTER_NOTE=""
          [ -n "$TAG" ] && FILTER_NOTE=" (filter: \`$TAG\`)"
          {
            echo "## Artifact Attestation Verification — \`$REPO\`${FILTER_NOTE}"
            echo ""
            echo "| Release | Artifact | Status |"
            echo "|---------|----------|:------:|"
          } >> "$GITHUB_STEP_SUMMARY"

          # ── Iterate releases ────────────────────────────────────────────────
          while IFS= read -r tag; do
            [ -z "$tag" ] && continue
            echo "::group::Release: $tag"

            WORKDIR=$(mktemp -d)
            DOWNLOAD_OK=true

            if ! gh release download "$tag" --repo "$REPO" --dir "$WORKDIR" 2>&1; then
              echo "Warning: Could not download assets for '$tag' (release may have no uploaded assets)"
              DOWNLOAD_OK=false
              RELEASE_ERRORS=$((RELEASE_ERRORS + 1))
              echo "| \`$tag\` | _(no assets)_ | ⚠️ |" >> "$GITHUB_STEP_SUMMARY"
            fi

            if $DOWNLOAD_OK; then
              ASSET_COUNT=0
              for artifact in "$WORKDIR"/*; do
                [ -e "$artifact" ] || continue
                ASSET_COUNT=$((ASSET_COUNT + 1))
                name=$(basename "$artifact")
                echo "  Verifying: $name"
                if gh attestation verify "$artifact" --repo "$REPO" 2>&1; then
                  echo "  ✓ $name — attestation verified"
                  TOTAL_VERIFIED=$((TOTAL_VERIFIED + 1))
                  echo "| \`$tag\` | \`$name\` | ✅ |" >> "$GITHUB_STEP_SUMMARY"
                else
                  echo "  ✗ $name — attestation verification FAILED"
                  TOTAL_FAILED=$((TOTAL_FAILED + 1))
                  echo "| \`$tag\` | \`$name\` | ❌ |" >> "$GITHUB_STEP_SUMMARY"
                  echo "- \`$tag\` / \`$name\`" >> "$FAILED_LIST_FILE"
                fi
              done

              if [ "$ASSET_COUNT" -eq 0 ]; then
                echo "  (No downloadable assets in this release)"
                echo "| \`$tag\` | _(no assets)_ | ⚠️ |" >> "$GITHUB_STEP_SUMMARY"
              fi
            fi

            rm -rf "$WORKDIR"
            echo "::endgroup::"
          done <<< "$TAGS"

          # ── Summary footer ──────────────────────────────────────────────────
          {
            echo ""
            echo "---"
            echo ""
            echo "| | Count |"
            echo "|---|---:|"
            echo "| ✅ Verified | **$TOTAL_VERIFIED** |"
            echo "| ❌ Failed   | **$TOTAL_FAILED** |"
            if [ "$RELEASE_ERRORS" -gt 0 ]; then
              echo "| ⚠️ Download errors | **$RELEASE_ERRORS** |"
            fi
          } >> "$GITHUB_STEP_SUMMARY"

          echo ""
          echo "============================================================"
          echo "Verification summary for $REPO"
          echo "  Artifacts verified:  $TOTAL_VERIFIED"
          echo "  Artifacts failed:    $TOTAL_FAILED"
          [ "$RELEASE_ERRORS" -gt 0 ] && echo "  Releases with download errors: $RELEASE_ERRORS"
          echo "============================================================"

          echo "verified=$TOTAL_VERIFIED" >> "$GITHUB_OUTPUT"
          echo "failed=$TOTAL_FAILED"    >> "$GITHUB_OUTPUT"

          if [ "$TOTAL_FAILED" -gt 0 ]; then
            echo "::error::$TOTAL_FAILED artifact(s) failed attestation verification in $REPO"

            # ── Open GitHub issue if requested ──────────────────────────────
            if [ "${OPEN_ISSUE:-false}" = "true" ]; then
              echo "Opening issue on $CALLER_REPO ..."
              {
                echo "## Attestation Verification Failures"
                echo ""
                echo "| Field | Value |"
                echo "|-------|-------|"
                echo "| **Repository checked** | \`$REPO\` |"
                echo "| **Workflow run** | [$RUN_URL]($RUN_URL) |"
                echo "| **Failed artifacts** | $TOTAL_FAILED |"
                echo ""
                echo "### Failed artifacts"
                echo ""
                cat "$FAILED_LIST_FILE"
                echo ""
                echo "---"
                echo "*This issue was opened automatically by the [artifact attestation verification workflow]($RUN_URL).*"
              } > /tmp/issue_body.md

              gh issue create \
                --repo "$CALLER_REPO" \
                --title "❌ Attestation verification failed for \`$REPO\`" \
                --body-file /tmp/issue_body.md \
                --label "bug" \
              || echo "::warning::Could not create issue — ensure the calling workflow grants \`issues: write\` permission"
            fi

            exit 1
          fi
